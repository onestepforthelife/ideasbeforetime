# OLDTESTSCRIPTS - Consolidated 2025-12-09T09:35:02.749Z


================================================================================
FILE: check-all-4week-issues.js
================================================================================

#!/usr/bin/env node

const https = require('https');

const issues = [
    // Week 1-2: Navigation/Footer consistency
    { check: 'navigation', pages: ['blog', 'about', 'cv', 'jobs', 'market-reports'] },
    // Week 2-3: Purple colors removed
    { check: 'purple', files: ['*.html', '*.css', '*.js'] },
    // Week 3: Double headers
    { check: 'double-headers', pages: ['all'] },
    // Week 3-4: Blue backgrounds
    { check: 'blue-bg', pages: ['blog', 'linkedin'] },
    // Week 4: 308 redirects
    { check: '308-redirects', pages: ['blog', 'about', 'cv', 'jobs', 'market-reports', 'spo', 'innovations', 'library'] }
];

console.log('üîç CHECKING ALL ISSUES FROM LAST 4 WEEKS\n');

const testUrl = (path) => {
    return new Promise((resolve) => {
        https.get(`https://onestepforthelife.com${path}`, { 
            headers: { 'User-Agent': 'Mozilla/5.0' }
        }, (res) => {
            resolve({ path, status: res.statusCode });
        }).on('error', () => {
            resolve({ path, status: 'ERROR' });
        });
    });
};

(async () => {
    const results = {
        '308-redirects': [],
        'other-issues': []
    };

    // Test 308 redirects
    console.log('Testing 308 redirects...');
    const pages = ['/', '/blog', '/about', '/cv', '/jobs', '/market-reports', '/spo', '/innovations', '/library'];
    
    for (const page of pages) {
        const result = await testUrl(page);
        if (result.status === 308 || result.status === 302) {
            results['308-redirects'].push(result);
            console.log(`‚ùå ${page}: ${result.status}`);
        } else if (result.status === 200) {
            console.log(`‚úÖ ${page}: 200 OK`);
        } else {
            console.log(`‚ö†Ô∏è  ${page}: ${result.status}`);
        }
    }

    console.log('\n============================================================');
    console.log('üìä SUMMARY');
    console.log('============================================================');
    console.log(`308/302 Redirects: ${results['308-redirects'].length}`);
    
    if (results['308-redirects'].length > 0) {
        console.log('\nüö® CRITICAL: Still have 308 redirects!');
        console.log('Root cause: Changes not pushed to GitHub yet');
        console.log('\nFIX:');
        console.log('1. git add .');
        console.log('2. git commit -m "Fix: Update all links to extensionless URLs"');
        console.log('3. git push');
        console.log('4. Wait 2-5 min for deployment');
        console.log('5. Purge Cloudflare cache');
        console.log('6. Wait 5-10 min');
        console.log('7. Test again');
    } else {
        console.log('\n‚úÖ All pages working!');
    }
})();



================================================================================
FILE: check-todays-mistake-patterns.js
================================================================================

#!/usr/bin/env node

/**
 * CHECK FOR TODAY'S MISTAKE PATTERNS
 * 
 * Checks all pages for similar mistakes to today:
 * 1. Vague naming (bad, wrong, broken in titles)
 * 2. Confusing labels (AI vs Tool confusion)
 * 3. Wrong categorization (blog labeled as tool)
 * 4. Missing clarification (unclear purpose)
 */

const fs = require('fs');
const path = require('path');

console.log('üîç CHECKING FOR TODAY\'S MISTAKE PATTERNS\n');

const issues = {
    vagueNaming: [],
    confusingLabels: [],
    wrongCategorization: [],
    missingClarification: [],
    oldDomain: [],
    missingDescription: []
};

// Get all HTML files
const files = fs.readdirSync('.').filter(f => f.endsWith('.html'));

console.log(`Checking ${files.length} HTML files...\n`);

files.forEach(file => {
    try {
        const content = fs.readFileSync(file, 'utf8');
        
        // 1. Check for vague terms in titles/headings (but allow descriptive uses)
        const titleMatch = content.match(/<title>([^<]+)<\/title>/);
        if (titleMatch) {
            const title = titleMatch[1];
            // Flag only if vague term is the MAIN subject, not descriptive
            // Bad: "Error Dashboard", "Fix Problems"
            // OK: "Site Health Monitor - Real-Time Issue Detection"
            const vagueAsMain = /^(bad|wrong|broken|issue|problem|fix|error)\b/i.test(title);
            const vagueInMain = /^[^-|]+\b(bad|wrong|broken|fix|error)\b/i.test(title);
            
            if (vagueAsMain || vagueInMain) {
                // But allow if it's clearly descriptive (has context)
                if (!/(monitor|detection|solver|troubleshooter|guide)/i.test(title)) {
                    issues.vagueNaming.push({
                        file: file,
                        title: title,
                        issue: 'Vague term in title'
                    });
                }
            }
        }
        
        // 2. Check for AI vs Tool confusion (like GODA issue)
        if (content.includes('AI') && content.includes('tool')) {
            const h1Match = content.match(/<h1[^>]*>([^<]+)<\/h1>/);
            if (h1Match && /AI.*tool|tool.*AI/i.test(h1Match[1])) {
                // Check if it's actually an AI tool or troubleshooter
                if (!content.includes('AI-powered') && !content.includes('artificial intelligence')) {
                    issues.confusingLabels.push({
                        file: file,
                        heading: h1Match[1],
                        issue: 'Unclear if AI tool or troubleshooter'
                    });
                }
            }
        }
        
        // 3. Check for blog vs tool confusion
        if (file.includes('blog') || file.includes('post')) {
            if (content.includes('tool') && titleMatch) {
                const title = titleMatch[1].toLowerCase();
                if (title.includes('tool') && !title.includes('blog')) {
                    issues.wrongCategorization.push({
                        file: file,
                        title: titleMatch[1],
                        issue: 'Blog content labeled as tool'
                    });
                }
            }
        }
        
        // 4. Check for old domain references
        if (content.includes('ideasbeforetime.pages.dev')) {
            issues.oldDomain.push({
                file: file,
                issue: 'Still references old domain'
            });
        }
        
        // 5. Check for missing meta descriptions
        if (!content.includes('<meta name="description"')) {
            // Only flag main pages, not test files
            if (!file.startsWith('test-') && !file.includes('template')) {
                issues.missingDescription.push({
                    file: file,
                    issue: 'Missing meta description'
                });
            }
        }
        
    } catch (err) {
        // Skip files that can't be read
    }
});

// Report results
console.log('üìã VAGUE NAMING (titles with bad/wrong/broken):');
if (issues.vagueNaming.length === 0) {
    console.log('   ‚úÖ None found\n');
} else {
    issues.vagueNaming.forEach(item => {
        console.log(`   ‚ùå ${item.file}`);
        console.log(`      Title: "${item.title}"`);
    });
    console.log('');
}

console.log('üìã CONFUSING LABELS (AI vs Tool confusion):');
if (issues.confusingLabels.length === 0) {
    console.log('   ‚úÖ None found\n');
} else {
    issues.confusingLabels.forEach(item => {
        console.log(`   ‚ö†Ô∏è  ${item.file}`);
        console.log(`      Heading: "${item.heading}"`);
    });
    console.log('');
}

console.log('üìã WRONG CATEGORIZATION (blog labeled as tool):');
if (issues.wrongCategorization.length === 0) {
    console.log('   ‚úÖ None found\n');
} else {
    issues.wrongCategorization.forEach(item => {
        console.log(`   ‚ùå ${item.file}`);
        console.log(`      Title: "${item.title}"`);
    });
    console.log('');
}

console.log('üìã OLD DOMAIN REFERENCES (ideasbeforetime.pages.dev):');
if (issues.oldDomain.length === 0) {
    console.log('   ‚úÖ None found\n');
} else {
    issues.oldDomain.forEach(item => {
        console.log(`   ‚ö†Ô∏è  ${item.file}`);
    });
    console.log('');
}

console.log('üìã MISSING META DESCRIPTIONS (SEO issue):');
if (issues.missingDescription.length === 0) {
    console.log('   ‚úÖ All main pages have descriptions\n');
} else {
    console.log(`   ‚ö†Ô∏è  ${issues.missingDescription.length} pages missing descriptions`);
    // Show first 10
    issues.missingDescription.slice(0, 10).forEach(item => {
        console.log(`      - ${item.file}`);
    });
    if (issues.missingDescription.length > 10) {
        console.log(`      ... and ${issues.missingDescription.length - 10} more`);
    }
    console.log('');
}

const totalIssues = issues.vagueNaming.length + 
                    issues.confusingLabels.length + 
                    issues.wrongCategorization.length + 
                    issues.oldDomain.length;

console.log('='.repeat(60));
console.log(`üìä TOTAL PATTERN ISSUES: ${totalIssues}`);
console.log(`   (Not counting ${issues.missingDescription.length} missing descriptions)`);
console.log('='.repeat(60));

// Save detailed report
const report = {
    timestamp: new Date().toISOString(),
    filesChecked: files.length,
    issues: issues,
    summary: {
        vagueNaming: issues.vagueNaming.length,
        confusingLabels: issues.confusingLabels.length,
        wrongCategorization: issues.wrongCategorization.length,
        oldDomain: issues.oldDomain.length,
        missingDescription: issues.missingDescription.length,
        total: totalIssues
    }
};

fs.writeFileSync('PATTERN_CHECK_REPORT_DEC7.json', JSON.stringify(report, null, 2));
console.log('\nüìÑ Detailed report saved: PATTERN_CHECK_REPORT_DEC7.json');

// Exit code
process.exit(totalIssues > 0 ? 1 : 0);



================================================================================
FILE: check-real-typography-alignment.js
================================================================================

const fs = require('fs');

console.log('üîç CHECKING: Real Typography & Alignment Issues\n');
console.log('='.repeat(70));

const issues = {
    smallText: [],
    leftAligned: [],
    total: 0
};

const files = fs.readdirSync('.').filter(f => f.endsWith('.html'));

files.forEach(file => {
    const content = fs.readFileSync(file, 'utf8');
    
    // Check 1: Small body text (< 14px or < 0.875em)
    const bodyFontSizes = content.match(/body\s*{[^}]*font-size:\s*([^;]+)/gi) || [];
    bodyFontSizes.forEach(match => {
        const size = match.match(/font-size:\s*([^;]+)/i)?.[1];
        if (size) {
            const px = parseInt(size);
            const em = parseFloat(size);
            if ((size.includes('px') && px < 14) || (size.includes('em') && em < 0.875)) {
                issues.smallText.push({
                    file: file,
                    element: 'body',
                    size: size,
                    issue: 'Text too small (< 14px)'
                });
                issues.total++;
            }
        }
    });
    
    // Check 2: Small paragraph text
    const pFontSizes = content.match(/p\s*{[^}]*font-size:\s*([^;]+)/gi) || [];
    pFontSizes.forEach(match => {
        const size = match.match(/font-size:\s*([^;]+)/i)?.[1];
        if (size) {
            const px = parseInt(size);
            if (size.includes('px') && px < 14) {
                issues.smallText.push({
                    file: file,
                    element: 'p',
                    size: size,
                    issue: 'Paragraph text too small (< 14px)'
                });
                issues.total++;
            }
        }
    });
    
    // Check 3: Headers that should be centered but are left-aligned
    // Look for hero sections, titles, CTAs that are left-aligned
    const heroLeftAligned = /\.hero\s*{[^}]*text-align:\s*left/gi.test(content);
    if (heroLeftAligned) {
        issues.leftAligned.push({
            file: file,
            element: '.hero',
            issue: 'Hero section left-aligned (should be center)'
        });
        issues.total++;
    }
    
    // Check for h1 in hero that's left-aligned
    const h1LeftInHero = /\.hero\s+h1\s*{[^}]*text-align:\s*left/gi.test(content);
    if (h1LeftInHero) {
        issues.leftAligned.push({
            file: file,
            element: '.hero h1',
            issue: 'Main heading left-aligned (should be center)'
        });
        issues.total++;
    }
    
    // Check for header tag with left alignment
    const headerLeftAligned = /header\s*{[^}]*text-align:\s*left/gi.test(content);
    if (headerLeftAligned) {
        issues.leftAligned.push({
            file: file,
            element: 'header',
            issue: 'Header left-aligned (should be center)'
        });
        issues.total++;
    }
});

// Report
console.log('\n1Ô∏è‚É£  SMALL TEXT ISSUES:');
if (issues.smallText.length === 0) {
    console.log('   ‚úÖ No small text issues found');
} else {
    const grouped = {};
    issues.smallText.forEach(item => {
        if (!grouped[item.file]) grouped[item.file] = [];
        grouped[item.file].push(`${item.element}: ${item.size}`);
    });
    Object.keys(grouped).forEach(file => {
        console.log(`   ‚ö†Ô∏è  ${file}: ${grouped[file].join(', ')}`);
    });
}

console.log('\n2Ô∏è‚É£  LEFT ALIGNMENT ISSUES (Should be centered):');
if (issues.leftAligned.length === 0) {
    console.log('   ‚úÖ No alignment issues found');
} else {
    const grouped = {};
    issues.leftAligned.forEach(item => {
        if (!grouped[item.file]) grouped[item.file] = [];
        grouped[item.file].push(item.element);
    });
    Object.keys(grouped).forEach(file => {
        console.log(`   ‚ö†Ô∏è  ${file}: ${grouped[file].join(', ')}`);
    });
}

console.log('\n' + '='.repeat(70));
console.log(`\nüìà SUMMARY:`);
console.log(`   Files scanned: ${files.length}`);
console.log(`   Small text issues: ${issues.smallText.length}`);
console.log(`   Left alignment issues: ${issues.leftAligned.length}`);
console.log(`   Total issues: ${issues.total}`);

// Save report
fs.writeFileSync('TYPOGRAPHY_ALIGNMENT_ISSUES.json', JSON.stringify(issues, null, 2));
console.log('\nüíæ Report saved: TYPOGRAPHY_ALIGNMENT_ISSUES.json');

process.exit(issues.total > 0 ? 1 : 0);



================================================================================
FILE: check-alignment-contrast-headers.js
================================================================================

const fs = require('fs');
const path = require('path');

console.log('üîç CHECKING: Alignment, Color Contrast, Header Font Size\n');
console.log('='.repeat(70));

const issues = {
    alignment: [],
    contrast: [],
    headerSize: [],
    total: 0
};

// Get all HTML files
const files = fs.readdirSync('.').filter(f => f.endsWith('.html'));

files.forEach(file => {
    const content = fs.readFileSync(file, 'utf8');
    const fileName = file;
    
    // Check 1: Text alignment issues (left/center/right inconsistency)
    const alignmentPatterns = [
        /text-align:\s*left/gi,
        /text-align:\s*center/gi,
        /text-align:\s*right/gi,
        /text-align:\s*justify/gi
    ];
    
    const alignments = {
        left: (content.match(/text-align:\s*left/gi) || []).length,
        center: (content.match(/text-align:\s*center/gi) || []).length,
        right: (content.match(/text-align:\s*right/gi) || []).length,
        justify: (content.match(/text-align:\s*justify/gi) || []).length
    };
    
    // Flag if mixed alignment (more than 2 types used significantly)
    const alignTypes = Object.values(alignments).filter(v => v > 2).length;
    if (alignTypes > 2) {
        issues.alignment.push({
            file: fileName,
            issue: `Mixed alignment: L:${alignments.left} C:${alignments.center} R:${alignments.right}`,
            severity: 'medium'
        });
        issues.total++;
    }
    
    // Check 2: Color contrast issues (light text on light bg, dark on dark)
    const contrastIssues = [];
    
    // Light colors on light backgrounds
    if (content.includes('color: white') && content.includes('background: white')) {
        contrastIssues.push('White on white');
    }
    if (content.includes('color: #fff') && content.includes('background: #fff')) {
        contrastIssues.push('#fff on #fff');
    }
    
    // Check for low contrast grays
    const lightGrayText = /color:\s*#[cdef][cdef][cdef]/gi.test(content);
    const lightGrayBg = /background:\s*#[cdef][cdef][cdef]/gi.test(content);
    if (lightGrayText && lightGrayBg) {
        contrastIssues.push('Light gray text on light gray background');
    }
    
    if (contrastIssues.length > 0) {
        issues.contrast.push({
            file: fileName,
            issue: contrastIssues.join(', '),
            severity: 'high'
        });
        issues.total++;
    }
    
    // Check 3: Header font size consistency
    const h1Sizes = content.match(/h1\s*{[^}]*font-size:\s*([^;]+)/gi) || [];
    const h2Sizes = content.match(/h2\s*{[^}]*font-size:\s*([^;]+)/gi) || [];
    const h3Sizes = content.match(/h3\s*{[^}]*font-size:\s*([^;]+)/gi) || [];
    
    const headerSizes = {
        h1: h1Sizes.map(s => s.match(/font-size:\s*([^;]+)/i)?.[1]).filter(Boolean),
        h2: h2Sizes.map(s => s.match(/font-size:\s*([^;]+)/i)?.[1]).filter(Boolean),
        h3: h3Sizes.map(s => s.match(/font-size:\s*([^;]+)/i)?.[1]).filter(Boolean)
    };
    
    // Check for very small headers (< 16px or < 1em)
    const smallHeaders = [];
    headerSizes.h1.forEach(size => {
        if (size.includes('px') && parseInt(size) < 24) smallHeaders.push(`H1: ${size}`);
        if (size.includes('em') && parseFloat(size) < 1.5) smallHeaders.push(`H1: ${size}`);
    });
    headerSizes.h2.forEach(size => {
        if (size.includes('px') && parseInt(size) < 20) smallHeaders.push(`H2: ${size}`);
        if (size.includes('em') && parseFloat(size) < 1.25) smallHeaders.push(`H2: ${size}`);
    });
    
    // Check for very large headers (> 60px or > 4em)
    const largeHeaders = [];
    headerSizes.h1.forEach(size => {
        if (size.includes('px') && parseInt(size) > 60) largeHeaders.push(`H1: ${size}`);
        if (size.includes('em') && parseFloat(size) > 4) largeHeaders.push(`H1: ${size}`);
    });
    
    if (smallHeaders.length > 0 || largeHeaders.length > 0) {
        issues.headerSize.push({
            file: fileName,
            issue: [...smallHeaders, ...largeHeaders].join(', '),
            severity: smallHeaders.length > 0 ? 'medium' : 'low'
        });
        issues.total++;
    }
});

// Report results
console.log('\nüìä RESULTS:\n');

console.log('1Ô∏è‚É£  ALIGNMENT ISSUES:');
if (issues.alignment.length === 0) {
    console.log('   ‚úÖ No major alignment issues found');
} else {
    issues.alignment.forEach(item => {
        console.log(`   ‚ö†Ô∏è  ${item.file}: ${item.issue}`);
    });
}

console.log('\n2Ô∏è‚É£  COLOR CONTRAST ISSUES:');
if (issues.contrast.length === 0) {
    console.log('   ‚úÖ No contrast issues found');
} else {
    issues.contrast.forEach(item => {
        console.log(`   üö® ${item.file}: ${item.issue}`);
    });
}

console.log('\n3Ô∏è‚É£  HEADER SIZE ISSUES:');
if (issues.headerSize.length === 0) {
    console.log('   ‚úÖ No header size issues found');
} else {
    issues.headerSize.forEach(item => {
        console.log(`   ‚ö†Ô∏è  ${item.file}: ${item.issue}`);
    });
}

console.log('\n' + '='.repeat(70));
console.log(`\nüìà SUMMARY:`);
console.log(`   Total files scanned: ${files.length}`);
console.log(`   Alignment issues: ${issues.alignment.length}`);
console.log(`   Contrast issues: ${issues.contrast.length}`);
console.log(`   Header size issues: ${issues.headerSize.length}`);
console.log(`   Total issues: ${issues.total}`);

// Save detailed report
const report = {
    timestamp: new Date().toISOString(),
    filesScanned: files.length,
    issues: issues,
    recommendations: []
};

if (issues.alignment.length > 0) {
    report.recommendations.push('Standardize text alignment across pages (prefer left-align for body text)');
}
if (issues.contrast.length > 0) {
    report.recommendations.push('Fix color contrast issues for WCAG AA compliance (4.5:1 ratio minimum)');
}
if (issues.headerSize.length > 0) {
    report.recommendations.push('Standardize header sizes: H1: 32-42px, H2: 24-32px, H3: 20-24px');
}

fs.writeFileSync('ALIGNMENT_CONTRAST_HEADER_REPORT.json', JSON.stringify(report, null, 2));
console.log('\nüíæ Detailed report saved: ALIGNMENT_CONTRAST_HEADER_REPORT.json');

process.exit(issues.total > 0 ? 1 : 0);



================================================================================
FILE: check-header-footer-all-pages.js
================================================================================

const fs = require('fs');
const path = require('path');

console.log('üîç Checking ALL pages for standard header/footer...\n');

// Get all HTML files
const files = fs.readdirSync('.').filter(f => f.endsWith('.html'));

const results = {
    hasNavigation: [],
    missingNavigation: [],
    hasFooter: [],
    missingFooter: [],
    hasNavigationCSS: [],
    missingNavigationCSS: [],
    hasFooterCSS: [],
    missingFooterCSS: []
};

files.forEach(file => {
    const content = fs.readFileSync(file, 'utf8');
    
    // Check for navigation
    const hasNavJS = content.includes('common-navigation.js');
    const hasNavCSS = content.includes('common-navigation.css');
    const hasFooterJS = content.includes('common-footer.js');
    const hasFooterCSS = content.includes('common-footer.css');
    
    if (hasNavJS) {
        results.hasNavigation.push(file);
    } else {
        results.missingNavigation.push(file);
    }
    
    if (hasNavCSS) {
        results.hasNavigationCSS.push(file);
    } else {
        results.missingNavigationCSS.push(file);
    }
    
    if (hasFooterJS) {
        results.hasFooter.push(file);
    } else {
        results.missingFooter.push(file);
    }
    
    if (hasFooterCSS) {
        results.hasFooterCSS.push(file);
    } else {
        results.missingFooterCSS.push(file);
    }
});

console.log('üìä RESULTS:\n');
console.log(`Total HTML files: ${files.length}\n`);

console.log('‚úÖ NAVIGATION JS (common-navigation.js):');
console.log(`   Has: ${results.hasNavigation.length} files`);
console.log(`   Missing: ${results.missingNavigation.length} files\n`);

console.log('‚úÖ NAVIGATION CSS (common-navigation.css):');
console.log(`   Has: ${results.hasNavigationCSS.length} files`);
console.log(`   Missing: ${results.missingNavigationCSS.length} files\n`);

console.log('‚úÖ FOOTER JS (common-footer.js):');
console.log(`   Has: ${results.hasFooter.length} files`);
console.log(`   Missing: ${results.missingFooter.length} files\n`);

console.log('‚úÖ FOOTER CSS (common-footer.css):');
console.log(`   Has: ${results.hasFooterCSS.length} files`);
console.log(`   Missing: ${results.missingFooterCSS.length} files\n`);

console.log('‚ùå FILES MISSING NAVIGATION JS:');
results.missingNavigation.forEach(f => console.log(`   - ${f}`));

console.log('\n‚ùå FILES MISSING NAVIGATION CSS:');
results.missingNavigationCSS.forEach(f => console.log(`   - ${f}`));

console.log('\n‚ùå FILES MISSING FOOTER JS:');
results.missingFooter.forEach(f => console.log(`   - ${f}`));

console.log('\n‚ùå FILES MISSING FOOTER CSS:');
results.missingFooterCSS.forEach(f => console.log(`   - ${f}`));

// Save report
const report = {
    totalFiles: files.length,
    summary: {
        navigationJS: {
            has: results.hasNavigation.length,
            missing: results.missingNavigation.length
        },
        navigationCSS: {
            has: results.hasNavigationCSS.length,
            missing: results.missingNavigationCSS.length
        },
        footerJS: {
            has: results.hasFooter.length,
            missing: results.missingFooter.length
        },
        footerCSS: {
            has: results.hasFooterCSS.length,
            missing: results.missingFooterCSS.length
        }
    },
    missingFiles: {
        navigationJS: results.missingNavigation,
        navigationCSS: results.missingNavigationCSS,
        footerJS: results.missingFooter,
        footerCSS: results.missingFooterCSS
    }
};

fs.writeFileSync('HEADER_FOOTER_CHECK_REPORT.json', JSON.stringify(report, null, 2));
console.log('\n‚úÖ Report saved to: HEADER_FOOTER_CHECK_REPORT.json');



================================================================================
FILE: check-all-pages-comprehensive.js
================================================================================

#!/usr/bin/env node

/**
 * COMPREHENSIVE PAGE CHECKER
 * Check ALL pages for common issues
 */

const fs = require('fs');

console.log('üîç COMPREHENSIVE PAGE CHECK\n');

// Get ALL HTML files
const files = fs.readdirSync('.')
    .filter(f => f.endsWith('.html'))
    .sort();

console.log(`Found ${files.length} HTML files\n`);

const issues = {
    missingNavigation: [],
    missingFooter: [],
    wrongBackground: [],
    missingQuickAccess: [],
    missingGoda: [],
    truncatedContent: [],
    poorContrast: []
};

files.forEach(file => {
    try {
        const content = fs.readFileSync(file, 'utf8');
        
        // Check 1: Navigation
        if (!content.includes('common-navigation.js')) {
            issues.missingNavigation.push(file);
        }
        
        // Check 2: Footer
        if (!content.includes('common-footer.js')) {
            issues.missingFooter.push(file);
        }
        
        // Check 3: Background color (should be bright blue for consistency)
        if (content.includes('background:linear-gradient(135deg,#5a6c7d')) {
            issues.wrongBackground.push(file);
        }
        
        // Check 4: Quick Access Widget
        if (!content.includes('quick-access-widget') && !content.includes('Quick Access')) {
            issues.missingQuickAccess.push(file);
        }
        
        // Check 5: GODA Chatbot
        if (!content.includes('goda-chatbot.js')) {
            issues.missingGoda.push(file);
        }
        
        // Check 6: Truncated content (blog posts)
        if (file.startsWith('blog-post-')) {
            const contentMatch = content.match(/<div class="content">([\s\S]*?)<\/div>/);
            if (contentMatch && contentMatch[1].length < 200) {
                issues.truncatedContent.push(file);
            }
        }
        
        // Check 7: Poor contrast (gray backgrounds)
        if (content.includes('#5a6c7d') || content.includes('#8b9aa7')) {
            issues.poorContrast.push(file);
        }
        
    } catch (error) {
        console.error(`‚ùå Error reading ${file}:`, error.message);
    }
});

// Report results
console.log('üìä RESULTS:\n');

let totalIssues = 0;

if (issues.missingNavigation.length > 0) {
    console.log(`‚ùå Missing Navigation (${issues.missingNavigation.length}):`);
    issues.missingNavigation.slice(0, 10).forEach(f => console.log(`   - ${f}`));
    if (issues.missingNavigation.length > 10) console.log(`   ... and ${issues.missingNavigation.length - 10} more`);
    totalIssues += issues.missingNavigation.length;
    console.log();
}

if (issues.missingFooter.length > 0) {
    console.log(`‚ùå Missing Footer (${issues.missingFooter.length}):`);
    issues.missingFooter.slice(0, 10).forEach(f => console.log(`   - ${f}`));
    if (issues.missingFooter.length > 10) console.log(`   ... and ${issues.missingFooter.length - 10} more`);
    totalIssues += issues.missingFooter.length;
    console.log();
}

if (issues.wrongBackground.length > 0) {
    console.log(`‚ö†Ô∏è  Wrong Background Color (${issues.wrongBackground.length}):`);
    issues.wrongBackground.slice(0, 10).forEach(f => console.log(`   - ${f}`));
    if (issues.wrongBackground.length > 10) console.log(`   ... and ${issues.wrongBackground.length - 10} more`);
    totalIssues += issues.wrongBackground.length;
    console.log();
}

if (issues.missingQuickAccess.length > 0) {
    console.log(`‚ö†Ô∏è  Missing Quick Access (${issues.missingQuickAccess.length}):`);
    issues.missingQuickAccess.slice(0, 10).forEach(f => console.log(`   - ${f}`));
    if (issues.missingQuickAccess.length > 10) console.log(`   ... and ${issues.missingQuickAccess.length - 10} more`);
    totalIssues += issues.missingQuickAccess.length;
    console.log();
}

if (issues.missingGoda.length > 0) {
    console.log(`‚ö†Ô∏è  Missing GODA Chatbot (${issues.missingGoda.length}):`);
    issues.missingGoda.slice(0, 10).forEach(f => console.log(`   - ${f}`));
    if (issues.missingGoda.length > 10) console.log(`   ... and ${issues.missingGoda.length - 10} more`);
    totalIssues += issues.missingGoda.length;
    console.log();
}

if (issues.truncatedContent.length > 0) {
    console.log(`‚ö†Ô∏è  Truncated Content (${issues.truncatedContent.length}):`);
    issues.truncatedContent.slice(0, 10).forEach(f => console.log(`   - ${f}`));
    if (issues.truncatedContent.length > 10) console.log(`   ... and ${issues.truncatedContent.length - 10} more`);
    totalIssues += issues.truncatedContent.length;
    console.log();
}

if (issues.poorContrast.length > 0) {
    console.log(`‚ö†Ô∏è  Poor Contrast Colors (${issues.poorContrast.length}):`);
    issues.poorContrast.slice(0, 10).forEach(f => console.log(`   - ${f}`));
    if (issues.poorContrast.length > 10) console.log(`   ... and ${issues.poorContrast.length - 10} more`);
    totalIssues += issues.poorContrast.length;
    console.log();
}

console.log('='.repeat(60));
if (totalIssues === 0) {
    console.log('‚úÖ ALL PAGES PERFECT!');
} else {
    console.log(`‚ö†Ô∏è  Total Issues: ${totalIssues}`);
    console.log('\nüí° Run fix scripts to resolve these issues');
}

// Save detailed report
const report = {
    timestamp: new Date().toISOString(),
    totalFiles: files.length,
    totalIssues,
    issues
};

fs.writeFileSync('ALL_PAGES_CHECK_REPORT.json', JSON.stringify(report, null, 2));
console.log('\nüìÑ Detailed report saved: ALL_PAGES_CHECK_REPORT.json');



================================================================================
FILE: diagnose-all-broken-items.js
================================================================================

#!/usr/bin/env node

/**
 * DAY 1: COMPREHENSIVE DIAGNOSIS
 * Check what's actually broken before fixing anything
 */

const fs = require('fs');

console.log('üîç DAY 1: COMPREHENSIVE DIAGNOSIS\n');
console.log('Checking what\'s actually broken...\n');
console.log('='.repeat(70) + '\n');

const issues = {
    critical: [],
    high: [],
    medium: [],
    working: []
};

// 1. CHECK SPO TOOL
console.log('1Ô∏è‚É£  SPO TOOL (social-optimizer-app.html)');
console.log('-'.repeat(70));

if (fs.existsSync('social-optimizer-app.html')) {
    const spo = fs.readFileSync('social-optimizer-app.html', 'utf8');
    
    console.log('‚úÖ File exists');
    
    // Check for form
    const hasForm = spo.includes('<form') || spo.includes('id="profileForm"');
    console.log(hasForm ? '‚úÖ Has form element' : '‚ùå No form element');
    
    // Check for navigation/next button
    const hasNextButton = spo.includes('type="submit"') || spo.includes('Next') || spo.includes('Generate');
    console.log(hasNextButton ? '‚úÖ Has submit/next button' : '‚ùå No submit button');
    
    // Check for JavaScript
    const hasJS = spo.includes('<script') || spo.includes('.js"');
    console.log(hasJS ? '‚úÖ Has JavaScript' : '‚ùå No JavaScript');
    
    // Check for AI integration
    const hasAI = spo.includes('gemini') || spo.includes('openai') || spo.includes('api');
    console.log(hasAI ? '‚úÖ Has AI integration' : '‚ö†Ô∏è  No AI integration found');
    
    // Check for navigation to results page
    const hasNavigation = spo.includes('window.location') || spo.includes('href=') || spo.includes('action=');
    console.log(hasNavigation ? '‚úÖ Has navigation logic' : '‚ùå No navigation logic');
    
    if (!hasForm || !hasNextButton || !hasNavigation) {
        issues.critical.push({
            item: 'SPO Tool',
            problem: 'Missing critical elements',
            details: [
                !hasForm ? 'No form element' : null,
                !hasNextButton ? 'No submit button' : null,
                !hasNavigation ? 'No navigation logic' : null
            ].filter(Boolean)
        });
    } else if (!hasAI) {
        issues.high.push({
            item: 'SPO Tool',
            problem: 'No AI integration',
            details: ['May be using templates instead of real AI']
        });
    } else {
        issues.working.push('SPO Tool structure looks complete');
    }
} else {
    console.log('‚ùå FILE NOT FOUND');
    issues.critical.push({
        item: 'SPO Tool',
        problem: 'File does not exist',
        details: ['social-optimizer-app.html missing']
    });
}

// 2. CHECK GODA CHATBOT
console.log('\n2Ô∏è‚É£  GODA CHATBOT (goda-chatbot.js)');
console.log('-'.repeat(70));

if (fs.existsSync('goda-chatbot.js')) {
    const goda = fs.readFileSync('goda-chatbot.js', 'utf8');
    
    console.log('‚úÖ File exists');
    
    // Check for basic structure
    const hasInit = goda.includes('function') || goda.includes('const') || goda.includes('class');
    console.log(hasInit ? '‚úÖ Has code structure' : '‚ùå Empty or invalid');
    
    // Check for UI elements
    const hasUI = goda.includes('createElement') || goda.includes('innerHTML') || goda.includes('button');
    console.log(hasUI ? '‚úÖ Has UI creation' : '‚ùå No UI creation');
    
    // Check for API calls
    const hasAPI = goda.includes('fetch') || goda.includes('XMLHttpRequest') || goda.includes('api');
    console.log(hasAPI ? '‚úÖ Has API calls' : '‚ùå No API calls');
    
    // Check for event listeners
    const hasEvents = goda.includes('addEventListener') || goda.includes('onclick');
    console.log(hasEvents ? '‚úÖ Has event listeners' : '‚ùå No event listeners');
    
    if (!hasInit || !hasUI || !hasEvents) {
        issues.critical.push({
            item: 'GODA Chatbot',
            problem: 'Missing critical functionality',
            details: [
                !hasInit ? 'No code structure' : null,
                !hasUI ? 'No UI creation' : null,
                !hasEvents ? 'No event listeners' : null
            ].filter(Boolean)
        });
    } else if (!hasAPI) {
        issues.high.push({
            item: 'GODA Chatbot',
            problem: 'No API integration',
            details: ['Cannot communicate with backend']
        });
    } else {
        issues.working.push('GODA Chatbot structure looks complete');
    }
} else {
    console.log('‚ùå FILE NOT FOUND');
    issues.critical.push({
        item: 'GODA Chatbot',
        problem: 'File does not exist',
        details: ['goda-chatbot.js missing']
    });
}

// 3. CHECK PAGES THAT INCLUDE GODA
console.log('\n3Ô∏è‚É£  PAGES WITH GODA CHATBOT');
console.log('-'.repeat(70));

const htmlFiles = fs.readdirSync('.').filter(f => f.endsWith('.html'));
let pagesWithGoda = 0;
let pagesMissingGoda = [];

htmlFiles.forEach(file => {
    const content = fs.readFileSync(file, 'utf8');
    if (content.includes('goda-chatbot.js')) {
        pagesWithGoda++;
    } else if (!file.includes('test-') && !file.includes('email-template')) {
        pagesMissingGoda.push(file);
    }
});

console.log(`‚úÖ ${pagesWithGoda} pages include GODA`);
console.log(`‚ö†Ô∏è  ${pagesMissingGoda.length} pages missing GODA`);

if (pagesMissingGoda.length > 0 && pagesMissingGoda.length < 10) {
    console.log('Missing from:', pagesMissingGoda.slice(0, 5).join(', '));
}

// 4. CHECK NAVIGATION CONSISTENCY
console.log('\n4Ô∏è‚É£  NAVIGATION CONSISTENCY');
console.log('-'.repeat(70));

let pagesWithNav = 0;
let pagesMissingNav = [];

htmlFiles.forEach(file => {
    const content = fs.readFileSync(file, 'utf8');
    const hasNav = content.includes('common-navigation.js') || content.includes('<nav');
    
    if (hasNav) {
        pagesWithNav++;
    } else if (!file.includes('test-') && !file.includes('email-template')) {
        pagesMissingNav.push(file);
    }
});

console.log(`‚úÖ ${pagesWithNav} pages have navigation`);
console.log(`‚ùå ${pagesMissingNav.length} pages missing navigation`);

if (pagesMissingNav.length > 0) {
    console.log('Missing from:', pagesMissingNav.slice(0, 10).join(', '));
    issues.high.push({
        item: 'Navigation',
        problem: `${pagesMissingNav.length} pages missing navigation`,
        details: pagesMissingNav.slice(0, 5)
    });
}

// 5. CHECK COMMON FILES
console.log('\n5Ô∏è‚É£  COMMON FILES');
console.log('-'.repeat(70));

const commonFiles = [
    'common-navigation.js',
    'common-footer.js',
    'common-footer.css',
    'common-styles.css',
    'universal-analytics.js'
];

commonFiles.forEach(file => {
    const exists = fs.existsSync(file);
    console.log(exists ? `‚úÖ ${file}` : `‚ùå ${file} MISSING`);
    
    if (!exists) {
        issues.critical.push({
            item: 'Common Files',
            problem: `${file} missing`,
            details: ['Required by multiple pages']
        });
    }
});

// SUMMARY
console.log('\n' + '='.repeat(70));
console.log('üìä DIAGNOSIS SUMMARY');
console.log('='.repeat(70));

console.log('\nüö® CRITICAL ISSUES (Must fix first):');
if (issues.critical.length === 0) {
    console.log('   ‚úÖ None found!');
} else {
    issues.critical.forEach((issue, i) => {
        console.log(`\n${i + 1}. ${issue.item}: ${issue.problem}`);
        issue.details.forEach(d => console.log(`   - ${d}`));
    });
}

console.log('\n‚ö†Ô∏è  HIGH PRIORITY ISSUES:');
if (issues.high.length === 0) {
    console.log('   ‚úÖ None found!');
} else {
    issues.high.forEach((issue, i) => {
        console.log(`\n${i + 1}. ${issue.item}: ${issue.problem}`);
        issue.details.forEach(d => console.log(`   - ${d}`));
    });
}

console.log('\n‚úÖ WORKING:');
if (issues.working.length === 0) {
    console.log('   ‚ö†Ô∏è  Nothing confirmed working yet');
} else {
    issues.working.forEach((item, i) => {
        console.log(`${i + 1}. ${item}`);
    });
}

// NEXT STEPS
console.log('\n' + '='.repeat(70));
console.log('üéØ NEXT STEPS');
console.log('='.repeat(70));

if (issues.critical.length > 0) {
    console.log('\n1. Fix critical issues first (in order):');
    issues.critical.forEach((issue, i) => {
        console.log(`   ${i + 1}. ${issue.item}`);
    });
}

if (issues.high.length > 0) {
    console.log('\n2. Then fix high priority issues:');
    issues.high.forEach((issue, i) => {
        console.log(`   ${i + 1}. ${issue.item}`);
    });
}

console.log('\n3. Test on live site after each fix');
console.log('4. Show proof before claiming "done"');

// SAVE REPORT
const report = {
    date: new Date().toISOString(),
    critical: issues.critical,
    high: issues.high,
    medium: issues.medium,
    working: issues.working,
    totalIssues: issues.critical.length + issues.high.length + issues.medium.length
};

fs.writeFileSync('DAY1_DIAGNOSIS_REPORT.json', JSON.stringify(report, null, 2));

console.log('\nüìÑ Report saved: DAY1_DIAGNOSIS_REPORT.json');
console.log('\n‚è≥ Waiting for your confirmation before fixing anything...\n');



================================================================================
FILE: test-adsense-implementation.js
================================================================================

/**
 * Test AdSense Implementation
 * Verify all 4 ad units are properly configured
 */

const fs = require('fs');

console.log('üß™ Testing AdSense Implementation...\n');

// Test 1: Check google-adsense.js exists and has all 4 ad units
console.log('Test 1: Checking google-adsense.js...');
try {
    const adsenseJs = fs.readFileSync('google-adsense.js', 'utf8');
    
    const adUnits = {
        'In-feed (5034645309)': adsenseJs.includes('5034645309'),
        'Display (9723865202)': adsenseJs.includes('9723865202'),
        'In-Article (5799371569)': adsenseJs.includes('5799371569'),
        'Multiplex (4786506942)': adsenseJs.includes('4786506942')
    };
    
    let allFound = true;
    for (const [name, found] of Object.entries(adUnits)) {
        console.log(`  ${found ? '‚úÖ' : '‚ùå'} ${name}`);
        if (!found) allFound = false;
    }
    
    if (allFound) {
        console.log('‚úÖ All 4 ad units found in google-adsense.js\n');
    } else {
        console.log('‚ùå Some ad units missing!\n');
        process.exit(1);
    }
} catch (error) {
    console.log('‚ùå google-adsense.js not found!\n');
    process.exit(1);
}

// Test 2: Check script is added to HTML pages
console.log('Test 2: Checking HTML pages have AdSense script...');
const testPages = [
    'index.html',
    'about.html',
    'blog.html',
    'kiro.html',
    'reports.html'
];

let pagesWithScript = 0;
let pagesWithoutScript = [];

testPages.forEach(page => {
    try {
        const content = fs.readFileSync(page, 'utf8');
        if (content.includes('google-adsense.js')) {
            pagesWithScript++;
            console.log(`  ‚úÖ ${page}`);
        } else {
            pagesWithoutScript.push(page);
            console.log(`  ‚ùå ${page} - Missing script tag`);
        }
    } catch (error) {
        console.log(`  ‚ö†Ô∏è  ${page} - Not found`);
    }
});

console.log(`\nüìä Summary: ${pagesWithScript}/${testPages.length} pages have AdSense script\n`);

// Test 3: Verify ad placement logic
console.log('Test 3: Checking ad placement logic...');
const adsenseJs = fs.readFileSync('google-adsense.js', 'utf8');

const checks = {
    'createInfeedAd function': adsenseJs.includes('function createInfeedAd()'),
    'createDisplayAd function': adsenseJs.includes('function createDisplayAd()'),
    'createInArticleAd function': adsenseJs.includes('function createInArticleAd()'),
    'createMultiplexAd function': adsenseJs.includes('function createMultiplexAd()'),
    'insertAds function': adsenseJs.includes('function insertAds()'),
    'Auto-initialization': adsenseJs.includes('init()')
};

let allChecks = true;
for (const [check, passed] of Object.entries(checks)) {
    console.log(`  ${passed ? '‚úÖ' : '‚ùå'} ${check}`);
    if (!passed) allChecks = false;
}

console.log();

// Test 4: Check for syntax errors
console.log('Test 4: Checking for syntax errors...');
try {
    require('./google-adsense.js');
    console.log('  ‚ùå Cannot test in Node.js (browser-only code)\n');
} catch (error) {
    if (error.message.includes('document is not defined')) {
        console.log('  ‚úÖ No syntax errors (browser code detected)\n');
    } else {
        console.log(`  ‚ùå Syntax error: ${error.message}\n`);
        allChecks = false;
    }
}

// Final result
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
if (allChecks && pagesWithoutScript.length === 0) {
    console.log('‚úÖ ALL TESTS PASSED!');
    console.log('‚úÖ AdSense implementation is ready');
    console.log('‚úÖ All 4 ad units configured');
    console.log('‚úÖ Ready to upload to GitHub');
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    process.exit(0);
} else {
    console.log('‚ö†Ô∏è  SOME ISSUES FOUND');
    if (pagesWithoutScript.length > 0) {
        console.log(`‚ö†Ô∏è  ${pagesWithoutScript.length} pages missing script tag`);
    }
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');
    process.exit(1);
}


